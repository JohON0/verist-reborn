/*
 * Decompiled with CFR 0.153-SNAPSHOT (d6f6758-dirty).
 */
package im.expensive.utils.render;

import im.expensive.utils.client.IMinecraft;
import im.expensive.utils.render.FileUtil;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.FloatBuffer;
import java.util.HashMap;
import net.minecraft.client.shader.Framebuffer;
import net.minecraft.util.ResourceLocation;
import org.lwjgl.opengl.ARBShaderObjects;
import org.lwjgl.opengl.GL20;
import org.lwjgl.opengl.GL30;

public class ShaderUtil
implements IMinecraft {
    private final int programID = ARBShaderObjects.glCreateProgramObjectARB();
    public static ShaderUtil CORNER_ROUND_SHADER;
    public static ShaderUtil CORNER_ROUND_SHADER_TEXTURE;
    public static ShaderUtil GLOW_ROUND_SHADER;
    public static ShaderUtil GRADIENT_ROUND_SHADER;
    public static ShaderUtil TEXTURE_ROUND_SHADER;
    public static ShaderUtil ROUND_SHADER_OUTLINE;
    public static ShaderUtil GRADIENT_MASK_SHADER;
    public static ShaderUtil ROUND_SHADER;
    private static final HashMap<Integer, FloatBuffer> kernelCache;
    private final String roundedOut = "#version 120\n\n// \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445\nuniform vec2 size; // \u0440\u0430\u0437\u043c\u0435\u0440 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\nuniform vec4 round; // \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b \u0441\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u044f \u0443\u0433\u043b\u043e\u0432\nuniform vec2 smoothness; // \u043f\u043b\u0430\u0432\u043d\u043e\u0441\u0442\u044c \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043e\u0442 \u0446\u0432\u0435\u0442\u0430 \u043a \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u0438\nuniform float value; // \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\nuniform vec4 color; // \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\nuniform float outlineSize; // \u0440\u0430\u0437\u043c\u0435\u0440 \u043e\u0431\u0432\u043e\u0434\u043a\u0438\nuniform vec4 outlineColor; // \u0446\u0432\u0435\u0442 \u043e\u0431\u0432\u043e\u0434\u043a\u0438\n\n// \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\nfloat test(vec2 vec_1, vec2 vec_2, vec4 vec_4) {\n    vec_4.xy = (vec_1.x > 0.0) ? vec_4.xy : vec_4.zw;\n    vec_4.x = (vec_1.y > 0.0) ? vec_4.x : vec_4.y;\n    vec2 coords = abs(vec_1) - vec_2 + vec_4.x;\n    return min(max(coords.x, coords.y), 0.0) + length(max(coords, vec2(0.0f))) - vec_4.x;\n}\n\nvoid main() {\n    vec2 st = gl_TexCoord[0].st * size; // \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u0438\u043a\u0441\u0435\u043b\u044f\n    vec2 halfSize = 0.5 * size; // \u043f\u043e\u043b\u043e\u0432\u0438\u043d\u0430 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n    float sa = 1.0 - smoothstep(smoothness.x, smoothness.y, test(halfSize - st, halfSize - value, round));\n    // \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n    gl_FragColor = mix(vec4(color.rgb, 0.0), vec4(color.rgb, color.a), sa); // \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u0441 \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c\u044e sa\n   \n    // \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u0432\u043e\u0434\u043a\u0443\n    vec2 outlineSizeVec = size + vec2(outlineSize);\n    float outlineDist = test(halfSize - st, halfSize - value, round);\n    float outline = smoothstep(smoothness.x, smoothness.y, outlineDist) - smoothstep(smoothness.x, smoothness.y, outlineDist - outlineSize);\n    if (outlineDist < outlineSize)\n        gl_FragColor = mix(gl_FragColor, outlineColor, outline);\n}\n";
    private final String fog = "#version 120\n\nuniform float BLUR_AMOUNT = 1.6;\nuniform sampler2D depthtex0;\nuniform float near;\nuniform float far;\nuniform sampler2D textureIn;\nuniform vec2 texelSize, direction;\nuniform float startRadius;\nuniform float endRadius;\nuniform float depthStart;\nuniform float weights[256];\n\n\n#define offset texelSize * direction\n#define clipping far\n#define NOISE .5/255.0\n\n\nfloat getDepth(vec2 coord) {\n    return 2.0 * near * far / (far + near - (2.0 * texture2D(depthtex0, coord).x - 1.0) * (far - near)) / clipping;\n}\n\nvoid main() {\n    float depth = getDepth(gl_TexCoord[0].st);\n    vec4 finalColor;\n    if (depth >= depthStart) {\n        float totalWeight = weights[0];\n        vec3 blr = texture2D(textureIn, gl_TexCoord[0].st).rgb * weights[0];\n\n        for (float f = 0f; f <= mix(startRadius, endRadius, depth - depthStart); f++) {\n            blr += texture2D(textureIn, gl_TexCoord[0].st + f * offset).rgb * (weights[int(abs(f))]);\n            blr += texture2D(textureIn, gl_TexCoord[0].st - f * offset).rgb * (weights[int(abs(f))]);\n            totalWeight += (weights[int(abs(f))]) * 2.0;\n        }\n\n        finalColor = vec4(blr / totalWeight, 1);\n\n    }\n    else {\n        finalColor = vec4(texture2D(textureIn, gl_TexCoord[0].st).rgb, 1.0);\n    }\n\n    gl_FragColor = finalColor;\n}\n";
    private final String bloom = "#version 120\n\nuniform sampler2D textureIn, textureToCheck;\nuniform vec2 texelSize, direction;\nuniform float exposure, radius;\nuniform float weights[64];\nuniform bool avoidTexture;\n\n#define offset direction * texelSize\n\nvoid main() {\n    if (direction.y == 1 && avoidTexture) {\n        if (texture2D(textureToCheck, gl_TexCoord[0].st).a != 0.0) discard;\n    }\n    vec4 innerAlpha = texture2D(textureIn, gl_TexCoord[0].st);\n    innerAlpha *= innerAlpha.a;\n    innerAlpha *= weights[0];\n\n\n\n    for (float r = 1.0; r <= radius; r ++) {\n        vec4 colorCurrent1 = texture2D(textureIn, gl_TexCoord[0].st + offset * r);\n        vec4 colorCurrent2 = texture2D(textureIn, gl_TexCoord[0].st - offset * r);\n\n        colorCurrent1.rgb *= colorCurrent1.a;\n        colorCurrent2.rgb *= colorCurrent2.a;\n\n        innerAlpha += (colorCurrent1 + colorCurrent2) * weights[int(r)];\n\n    }\n\n    gl_FragColor = vec4(innerAlpha.rgb / innerAlpha.a, mix(innerAlpha.a, 1.0 - exp(-innerAlpha.a * exposure), step(0.0, direction.y)));\n}";
    String glowRect = "uniform vec2 rectSize; // \u0440\u0430\u0437\u043c\u0435\u0440\u044b \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\nuniform vec4 color1, color2, color3, color4; // \u0447\u0435\u0442\u044b\u0440\u0435 \u0446\u0432\u0435\u0442\u0430 \u0434\u043b\u044f \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442\u0430\nuniform float radius, soft; // \u0440\u0430\u0434\u0438\u0443\u0441 \u0438 \u0441\u0433\u043b\u0430\u0436\u0438\u0432\u0430\u043d\u0438\u0435 \u043a\u0440\u0443\u0433\u0430\n\n/* \u0424\u0443\u043d\u043a\u0446\u0438\u044f, \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u044e\u0449\u0430\u044f \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0442 \u0442\u043e\u0447\u043a\u0438 \u0434\u043e \u043a\u0440\u0443\u0433\u0430 \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u043c \u0440\u0430\u0434\u0438\u0443\u0441\u043e\u043c \u0438 \u0446\u0435\u043d\u0442\u0440\u043e\u043c */\nfloat roundSDF(vec2 p, vec2 b, float r) {\n    return length(max(abs(p) - b , 0.0)) - r;\n}\n\n/* \u0424\u0443\u043d\u043a\u0446\u0438\u044f, \u0441\u043e\u0437\u0434\u0430\u044e\u0449\u0430\u044f \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442 \u043f\u043e \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u043c \u0446\u0432\u0435\u0442\u0430\u043c */\nvec3 createGradient(vec2 coords, vec3 color1, vec3 color2, vec3 color3, vec3 color4){\n    vec3 color = mix(mix(color1.rgb, color2.rgb, coords.y), mix(color3.rgb, color4.rgb, coords.y), coords.x);\n    return color;\n}\n\nvoid main() {\n    vec2 st = gl_TexCoord[0].st; // \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u0438\u043a\u0441\u0435\u043b\u044f \u043d\u0430 \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u0435\n    vec2 halfSize = rectSize * .5; // \u043f\u043e\u043b\u043e\u0432\u0438\u043d\u0430 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u0432 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n    float dist = roundSDF(halfSize - (gl_TexCoord[0].st * rectSize), halfSize - (soft + (radius * 0.75)), radius); // \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0442 \u043f\u0438\u043a\u0441\u0435\u043b\u044f \u0434\u043e \u043a\u0440\u0443\u0433\u0430\n    float smoothedAlpha = (1. - smoothstep(-soft, soft, dist)) * color1.a; // \u0441\u0433\u043b\u0430\u0436\u0435\u043d\u043d\u0430\u044f \u0430\u043b\u044c\u0444\u0430-\u0441\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0430\u044f \u0446\u0432\u0435\u0442\u0430\n    gl_FragColor = mix(vec4(createGradient(st, color1.rgb, color2.rgb, color3.rgb, color4.rgb), 0.0), vec4(createGradient(st, color1.rgb, color2.rgb, color3.rgb, color4.rgb), smoothedAlpha), smoothedAlpha); // \u0441\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0435 \u0446\u0432\u0435\u0442\u0430 \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442\u0430 \u0441 \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c\u044e \u0438 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0430 \u043a\u043e\u043d\u0435\u0447\u043d\u043e\u0433\u043e \u0446\u0432\u0435\u0442\u0430 \u043f\u0438\u043a\u0441\u0435\u043b\u044f\n}";
    private final String roundRectOutline = "#version 120\n            \nuniform vec2 location, rectSize;\nuniform vec4 color, outlineColor1,outlineColor2,outlineColor3,outlineColor4;\nuniform float radius, outlineThickness;\n#define NOISE .5/255.0\n\nfloat roundedSDF(vec2 centerPos, vec2 size, float radius) {\n    return length(max(abs(centerPos) - size + radius, 0.0)) - radius;\n}\n\nvec3 createGradient(vec2 coords, vec3 color1, vec3 color2, vec3 color3, vec3 color4)\n{\n    vec3 color = mix(mix(color1.rgb, color2.rgb, coords.y), mix(color3.rgb, color4.rgb, coords.y), coords.x);\n    //Dithering the color\n    // from https://shader-tutorial.dev/advanced/color-banding-dithering/\n    color += mix(NOISE, -NOISE, fract(sin(dot(coords.xy, vec2(12.9898, 78.233))) * 43758.5453));\n    return color;\n}\n\nvoid main() {\n    float distance = roundedSDF(gl_FragCoord.xy - location - (rectSize * .5), (rectSize * .5) + (outlineThickness * 0.5) - 1.0, radius);\n\n    float blendAmount = smoothstep(0., 2., abs(distance) - (outlineThickness * 0.5));\n    vec4 outlineColor = vec4(createGradient(gl_TexCoord[0].st, outlineColor1.rgb, outlineColor2.rgb, outlineColor3.rgb, outlineColor4.rgb), outlineColor1.a);\n    vec4 insideColor = (distance < 0.) ? color : vec4(outlineColor.rgb,  0.0);\n    gl_FragColor = mix(outlineColor, insideColor, blendAmount);\n}\n";
    String gradientRoundRect = "#version 120\n\nuniform vec2 location, rectSize;\nuniform vec4 color1, color2, color3, color4;\nuniform float radius;\n\n#define NOISE .5/255.0\n\nfloat roundSDF(vec2 p, vec2 b, float r) {\n    return length(max(abs(p) - b , 0.0)) - r;\n}\n\nvec3 createGradient(vec2 coords, vec3 color1, vec3 color2, vec3 color3, vec3 color4){\n    vec3 color = mix(mix(color1.rgb, color2.rgb, coords.y), mix(color3.rgb, color4.rgb, coords.y), coords.x);\n    //Dithering the color\n    // from https://shader-tutorial.dev/advanced/color-banding-dithering/\n    color += mix(NOISE, -NOISE, fract(sin(dot(coords.xy, vec2(12.9898, 78.233))) * 43758.5453));\n    return color;\n}\n\nvoid main() {\n    vec2 st = gl_TexCoord[0].st;\n    vec2 halfSize = rectSize * .5;\n    \n    float smoothedAlpha =  (1.0-smoothstep(0.0, 2., roundSDF(halfSize - (gl_TexCoord[0].st * rectSize), halfSize - radius - 1., radius))) * color1.a;\n    gl_FragColor = vec4(createGradient(st, color1.rgb, color2.rgb, color3.rgb, color4.rgb), smoothedAlpha);\n}";
    String roundedRect = "#version 120\n\nuniform vec2 location, rectSize;\nuniform vec4 color;\nuniform float radius;\nuniform bool blur;\n\nfloat roundSDF(vec2 p, vec2 b, float r) {\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\n\nvoid main() {\n    vec2 rectHalf = rectSize * 0.5;\n    // Smooth the result (free antialiasing).\n    float smoothedAlpha =  (1.0-smoothstep(0.0, 1.0, roundSDF(rectHalf - (gl_TexCoord[0].st * rectSize), rectHalf - radius - 1., radius))) * color.a;\n    gl_FragColor = vec4(color.rgb, smoothedAlpha);// mix(quadColor, shadowColor, 0.0);\n\n}";
    String vertex = "#version 120       \nvoid main() {\n    // \u0412\u044b\u0431\u043e\u0440\u043a\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438\u0437 \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u044b \u0432\u043e \u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\u043d\u043e\u043c \u0448\u0435\u0439\u0434\u0435\u0440\u0435 (\u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b)\n    gl_TexCoord[0] = gl_MultiTexCoord0;\n    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n}\n";
    String texture = "uniform vec2 rectSize; // \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0438 \u0440\u0430\u0437\u043c\u0435\u0440 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\nuniform sampler2D textureIn; // \u0412\u0445\u043e\u0434\u043d\u0430\u044f \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u0430\nuniform float radius, alpha; // \u0420\u0430\u0434\u0438\u0443\u0441 \u0437\u0430\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u044f \u0443\u0433\u043b\u043e\u0432 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u0438 \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c\n\n// \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0434\u043b\u044f \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u043e\u0442 \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438 \u0434\u043e \u043a\u0440\u0430\u044f \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\nfloat roundedSDF(vec2 centerPos, vec2 size, float radius) {\n    return length(max(abs(centerPos) - size, 0.)) - radius;\n}\n\nvoid main() {\n    // \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043e\u0442 \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438 \u0434\u043e \u043a\u0440\u0430\u044f \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n    float distance = roundedSDF((rectSize * .5) - (gl_TexCoord[0].st * rectSize), (rectSize * .5) - radius - 1., radius);\n    \n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043f\u043b\u0430\u0432\u043d\u044b\u0439 \u043f\u0435\u0440\u0435\u0445\u043e\u0434 \u043e\u0442 \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u043a \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0439 \u043e\u0431\u043b\u0430\u0441\u0442\u0438\n    float smoothedAlpha = (1.0 - smoothstep(0.0, 2.0, distance)) * alpha;\n\n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043e\u043a\u043e\u043d\u0447\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u0446\u0432\u0435\u0442 \u043f\u0438\u043a\u0441\u0435\u043b\u044f, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \u0446\u0432\u0435\u0442 \u0438\u0437 \u0432\u0445\u043e\u0434\u043d\u043e\u0439 \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u044b \u0438 \u043f\u043b\u0430\u0432\u043d\u044b\u0439 \u043f\u0435\u0440\u0435\u0445\u043e\u0434 \u043c\u0435\u0436\u0434\u0443 \u0433\u0440\u0430\u043d\u0438\u0446\u0435\u0439 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u0438 \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0439 \u043e\u0431\u043b\u0430\u0441\u0442\u044c\u044e\n    gl_FragColor = vec4(texture2D(textureIn, gl_TexCoord[0].st).rgb, smoothedAlpha);\n}\n";
    String roundedCornerRect = "#version 120\n    // \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445\n    uniform vec2 size; // \u0440\u0430\u0437\u043c\u0435\u0440 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n    uniform vec4 round; // \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b \u0441\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u044f \u0443\u0433\u043b\u043e\u0432\n    uniform vec2 smoothness; // \u043f\u043b\u0430\u0432\u043d\u043e\u0441\u0442\u044c \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043e\u0442 \u0446\u0432\u0435\u0442\u0430 \u043a \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u0438\n    uniform float value; // \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n    uniform vec4 color; // \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n\n    // \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n    float test(vec2 vec_1, vec2 vec_2, vec4 vec_4) {\n        vec_4.xy = (vec_1.x > 0.0) ? vec_4.xy : vec_4.zw;\n        vec_4.x = (vec_1.y > 0.0) ? vec_4.x : vec_4.y;\n        vec2 coords = abs(vec_1) - vec_2 + vec_4.x;\n        return min(max(coords.x, coords.y), 0.0) + length(max(coords, vec2(0.0f))) - vec_4.x;\n    }\n\n\n    void main() {\n        vec2 st = gl_TexCoord[0].st * size; // \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u0438\u043a\u0441\u0435\u043b\u044f\n        vec2 halfSize = 0.5 * size; // \u043f\u043e\u043b\u043e\u0432\u0438\u043d\u0430 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n        float sa = 1.0 - smoothstep(smoothness.x, smoothness.y, test(halfSize - st, halfSize - value, round));\n        // \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n        gl_FragColor = mix(vec4(color.rgb, 0.0), vec4(color.rgb, color.a), sa); // \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u0441 \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c\u044e sa\n    }";
    String roundedCornerRectGradient = "#version 120\n    // \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445\n    uniform vec2 size; // \u0440\u0430\u0437\u043c\u0435\u0440 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n    uniform vec4 round; // \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b \u0441\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u044f \u0443\u0433\u043b\u043e\u0432\n    uniform vec2 smoothness; // \u043f\u043b\u0430\u0432\u043d\u043e\u0441\u0442\u044c \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043e\u0442 \u0446\u0432\u0435\u0442\u0430 \u043a \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u0438\n    uniform float value; // \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n    uniform vec4 color1; // \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n    uniform vec4 color2; // \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n    uniform vec4 color3; // \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n    uniform vec4 color4; // \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n    #define NOISE .5/255.0\n    // \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n    float test(vec2 vec_1, vec2 vec_2, vec4 vec_4) {\n        vec_4.xy = (vec_1.x > 0.0) ? vec_4.xy : vec_4.zw;\n        vec_4.x = (vec_1.y > 0.0) ? vec_4.x : vec_4.y;\n        vec2 coords = abs(vec_1) - vec_2 + vec_4.x;\n        return min(max(coords.x, coords.y), 0.0) + length(max(coords, vec2(0.0f))) - vec_4.x;\n    }\n\n    vec4 createGradient(vec2 coords, vec4 color1, vec4 color2, vec4 color3, vec4 color4)\n{\n    vec4 color = mix(mix(color1, color2, coords.y), mix(color3, color4, coords.y), coords.x);\n    //Dithering the color\n    // from https://shader-tutorial.dev/advanced/color-banding-dithering/\n    color += mix(NOISE, -NOISE, fract(sin(dot(coords.xy, vec2(12.9898, 78.233))) * 43758.5453));\n    return color;\n}\n\n    void main() {\n        vec2 st = gl_TexCoord[0].st * size; // \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u0438\u043a\u0441\u0435\u043b\u044f\n        vec2 halfSize = 0.5 * size; // \u043f\u043e\u043b\u043e\u0432\u0438\u043d\u0430 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n        float sa = 1.0 - smoothstep(smoothness.x, smoothness.y, test(halfSize - st, halfSize - value, round));\n        // \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n        vec4 color = createGradient(gl_TexCoord[0].st, color1, color2,color3,color4);\n        gl_FragColor = mix(vec4(color.rgb, 0.0), vec4(color.rgb, color.a), sa); // \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u0441 \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c\u044e sa\n    }";
    String roundedCornerRectTexture = "#version 120\n     // \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445\n     uniform vec2 size; // \u0440\u0430\u0437\u043c\u0435\u0440 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n     uniform vec4 round; // \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b \u0441\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u044f \u0443\u0433\u043b\u043e\u0432\n     uniform vec2 smoothness; // \u043f\u043b\u0430\u0432\u043d\u043e\u0441\u0442\u044c \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043e\u0442 \u0446\u0432\u0435\u0442\u0430 \u043a \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u0438\n     uniform float value; // \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n     uniform sampler2D textureIn;\n     uniform float alpha;\n\n     // \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n     float test(vec2 vec_1, vec2 vec_2, vec4 vec_4) {\n         vec_4.xy = (vec_1.x > 0.0) ? vec_4.xy : vec_4.zw;\n         vec_4.x = (vec_1.y > 0.0) ? vec_4.x : vec_4.y;\n         vec2 coords = abs(vec_1) - vec_2 + vec_4.x;\n         return min(max(coords.x, coords.y), 0.0) + length(max(coords, vec2(0.0f))) - vec_4.x;\n     }\n\n     void main() {\n         vec4 color = texture2D(textureIn, gl_TexCoord[0].st);\n         vec2 st = gl_TexCoord[0].st * size; // \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u0438\u043a\u0441\u0435\u043b\u044f\n         vec2 halfSize = 0.5 * size; // \u043f\u043e\u043b\u043e\u0432\u0438\u043d\u0430 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n         float sa = 1.0 - smoothstep(smoothness.x, smoothness.y, test(halfSize - st, halfSize - value, round));\n         // \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n         gl_FragColor = mix(vec4(color.rgb, 0.0), vec4(color.rgb, alpha), sa); // \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u0441 \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c\u044e sa\n     }";
    private String gradientMask = "#version 120\n\nuniform vec2 location, rectSize;\nuniform sampler2D tex;\nuniform vec3 color1, color2, color3, color4;\nuniform float alpha;\n\n#define NOISE .5/255.0\n\nvec3 createGradient(vec2 coords, vec3 color1, vec3 color2, vec3 color3, vec3 color4){\n    vec3 color = mix(mix(color1.rgb, color2.rgb, coords.y), mix(color3.rgb, color4.rgb, coords.y), coords.x);\n    //Dithering the color from https://shader-tutorial.dev/advanced/color-banding-dithering/\n    color += mix(NOISE, -NOISE, fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453));\n    return color;\n}\n\nvoid main() {\n    vec2 coords = (gl_FragCoord.xy - location) / rectSize;\n    float texColorAlpha = texture2D(tex, gl_TexCoord[0].st).a;\n    gl_FragColor = vec4(createGradient(coords, color1, color2, color3, color4), texColorAlpha * alpha);\n}";
    private String alphaMask = "#version 120\nuniform sampler2D tex;\nuniform float alpha;\n\n\nvoid main() {\n    float texColorAlpha = texture2D(tex, gl_TexCoord[0].st).a;\n    gl_FragColor = vec4(texture2D(tex, gl_TexCoord[0].st).rgb, texColorAlpha * alpha);\n}";
    private String kawaseUpBloom = "#version 120\n\nuniform sampler2D inTexture, textureToCheck;\nuniform vec2 halfpixel, offset, iResolution;\nuniform int check;\n\nvoid main() {\n  //  if(check && texture2D(textureToCheck, gl_TexCoord[0].st).a > 0.0) discard;\n    vec2 uv = vec2(gl_FragCoord.xy / iResolution);\n\n    vec4 sum = texture2D(inTexture, uv + vec2(-halfpixel.x * 2.0, 0.0) * offset);\n    sum.rgb *= sum.a;\n    vec4 smpl1 =  texture2D(inTexture, uv + vec2(-halfpixel.x, halfpixel.y) * offset);\n    smpl1.rgb *= smpl1.a;\n    sum += smpl1 * 2.0;\n    vec4 smp2 = texture2D(inTexture, uv + vec2(0.0, halfpixel.y * 2.0) * offset);\n    smp2.rgb *= smp2.a;\n    sum += smp2;\n    vec4 smp3 = texture2D(inTexture, uv + vec2(halfpixel.x, halfpixel.y) * offset);\n    smp3.rgb *= smp3.a;\n    sum += smp3 * 2.0;\n    vec4 smp4 = texture2D(inTexture, uv + vec2(halfpixel.x * 2.0, 0.0) * offset);\n    smp4.rgb *= smp4.a;\n    sum += smp4;\n    vec4 smp5 = texture2D(inTexture, uv + vec2(halfpixel.x, -halfpixel.y) * offset);\n    smp5.rgb *= smp5.a;\n    sum += smp5 * 2.0;\n    vec4 smp6 = texture2D(inTexture, uv + vec2(0.0, -halfpixel.y * 2.0) * offset);\n    smp6.rgb *= smp6.a;\n    sum += smp6;\n    vec4 smp7 = texture2D(inTexture, uv + vec2(-halfpixel.x, -halfpixel.y) * offset);\n    smp7.rgb *= smp7.a;\n    sum += smp7 * 2.0;\n    vec4 result = sum / 12.0;\n    gl_FragColor = vec4(result.rgb / result.a, mix(result.a, result.a * (1.0 - texture2D(textureToCheck, gl_TexCoord[0].st).a),check));\n}";
    private String outline = "#version 120\n\nuniform vec4 color;\nuniform sampler2D textureIn, textureToCheck;\nuniform vec2 texelSize, direction;\nuniform float size;\n\n#define offset direction * texelSize\n\nvoid main() {\n    if (direction.y == 1) {\n        if (texture2D(textureToCheck, gl_TexCoord[0].st).a != 0.0) discard;\n    }\n\n    vec4 innerAlpha = texture2D(textureIn, gl_TexCoord[0].st);\n    innerAlpha *= innerAlpha.a;\n    for (float r = 1.0; r <= size; r ++) {\n        vec4 colorCurrent1 = texture2D(textureIn, gl_TexCoord[0].st + offset * r);\n        vec4 colorCurrent2 = texture2D(textureIn, gl_TexCoord[0].st - offset * r);\n        colorCurrent1.rgb *= colorCurrent1.a;\n        colorCurrent2.rgb *= colorCurrent2.a;\n        innerAlpha += (colorCurrent1 + colorCurrent2) * r;\n    }\n    gl_FragColor = vec4(color.rgb, mix(innerAlpha.a, 1.0 - exp(-innerAlpha.a), step(0.0, direction.y)));\n}";
    private String colorOut = "#version 120\n\nuniform vec4 color;\nuniform sampler2D textureIn, textureToCheck;\nuniform vec2 texelSize, direction;\nuniform float size;\n\n#define offset direction * texelSize\n\nvoid main() {\n    if (direction.y == 1) {\n        if (texture2D(textureToCheck, gl_TexCoord[0].st).a != 0.0) discard;\n    }\n\n    vec4 innerAlpha = texture2D(textureIn, gl_TexCoord[0].st);\n    innerAlpha *= innerAlpha.a;\n    for (float r = 1.0; r <= size; r ++) {\n        vec4 colorCurrent1 = texture2D(textureIn, gl_TexCoord[0].st + offset * r);\n        vec4 colorCurrent2 = texture2D(textureIn, gl_TexCoord[0].st - offset * r);\n        colorCurrent1.rgb *= colorCurrent1.a;\n        colorCurrent2.rgb *= colorCurrent2.a;\n        innerAlpha += (colorCurrent1 + colorCurrent2) * r;\n    }\n    gl_FragColor = vec4(innerAlpha.rgb / innerAlpha.a, mix(innerAlpha.a, 1.0 - exp(-innerAlpha.a), step(0.0, direction.y)));\n}";
    private String kawaseDownBloom = "#version 120\n\nuniform sampler2D inTexture;\nuniform vec2 offset, halfpixel, iResolution;\n\nvoid main() {\n    vec2 uv = vec2(gl_FragCoord.xy / iResolution);\n    vec4 sum = texture2D(inTexture, gl_TexCoord[0].st);\n    sum.rgb *= sum.a;\n    sum *= 4.0;\n    vec4 smp1 = texture2D(inTexture, uv - halfpixel.xy * offset);\n    smp1.rgb *= smp1.a;\n    sum += smp1;\n    vec4 smp2 = texture2D(inTexture, uv + halfpixel.xy * offset);\n    smp2.rgb *= smp2.a;\n    sum += smp2;\n    vec4 smp3 = texture2D(inTexture, uv + vec2(halfpixel.x, -halfpixel.y) * offset);\n    smp3.rgb *= smp3.a;\n    sum += smp3;\n    vec4 smp4 = texture2D(inTexture, uv - vec2(halfpixel.x, -halfpixel.y) * offset);\n    smp4.rgb *= smp4.a;\n    sum += smp4;\n    vec4 result = sum / 8.0;\n    gl_FragColor = vec4(result.rgb / result.a, result.a);\n}";

    public ShaderUtil(String fragmentShaderLoc) {
        try {
            int fragmentShaderID = switch (fragmentShaderLoc) {
                case "corner" -> this.createShader(new ByteArrayInputStream(this.roundedCornerRect.getBytes()), 35632);
                case "cornerGradient" -> this.createShader(new ByteArrayInputStream(this.roundedCornerRectGradient.getBytes()), 35632);
                case "noise" -> this.createShader(new ByteArrayInputStream("uniform sampler2D u_texture;\nuniform float u_value;\n#define NOISE .5/255.0\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 st = gl_TexCoord[0].st;\n\n    // \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0446\u0432\u0435\u0442\u0430 \u0438\u0437 \u0432\u0445\u043e\u0434\u043d\u043e\u0439 \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u044b\n    vec4 color = texture2D(u_texture, st);\n\n    float noise = (sin(st.x) * cos(st.y)) * random(st);\n\n    // \u041f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0448\u0443\u043c\u0430\n    color.rgb -= vec3(noise / u_value);\n    // \u041e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430 \u043d\u0430 \u0432\u044b\u0445\u043e\u0434\n    gl_FragColor = color;\n}\n".getBytes()), 35632);
                case "blur2" -> this.createShader(new ByteArrayInputStream("#version 120\n\n uniform sampler2D textureIn, textureToCheck;\n uniform vec2 texelSize, direction;\n uniform float exposure, radius;\n uniform float weights[256];\n uniform bool avoidTexture;\n\n #define offset direction * texelSize\n\n void main() {\n     if (direction.y >= 1 && avoidTexture) {\n         if (texture2D(textureToCheck, gl_TexCoord[0].st).a != 0.0) discard;\n     }\n     vec4 innerAlpha = texture2D(textureIn, gl_TexCoord[0].st);\n     innerAlpha *= innerAlpha.a;\n     innerAlpha *= weights[0];\n\n\n\n     for (float r = 1.0; r <= radius; r ++) {\n         vec4 colorCurrent1 = texture2D(textureIn, gl_TexCoord[0].st + offset * r);\n         vec4 colorCurrent2 = texture2D(textureIn, gl_TexCoord[0].st - offset * r);\n\n         colorCurrent1.rgb *= colorCurrent1.a;\n         colorCurrent2.rgb *= colorCurrent2.a;\n\n         innerAlpha += (colorCurrent1 + colorCurrent2) * weights[int(r)];\n\n     }\n\n     gl_FragColor = vec4(innerAlpha.rgb / innerAlpha.a, mix(innerAlpha.a, 1.0 - exp(-innerAlpha.a * exposure), step(0.0, direction.y)));\n }\n".getBytes()), 35632);
                case "blur2c" -> this.createShader(new ByteArrayInputStream("#version 120\n\n uniform vec4 color;\n uniform sampler2D textureIn, textureToCheck;\n uniform vec2 texelSize, direction;\n uniform float exposure, radius;\n uniform float weights[256];\n uniform bool avoidTexture;\n\n #define offset direction * texelSize\n\n void main() {\n     if (direction.y >= 1 && avoidTexture) {\n         if (texture2D(textureToCheck, gl_TexCoord[0].st).a != 0.0) discard;\n     }\n     vec4 innerAlpha = texture2D(textureIn, gl_TexCoord[0].st);\n     innerAlpha *= innerAlpha.a;\n     innerAlpha *= weights[0];\n\n\n\n     for (float r = 1.0; r <= radius; r ++) {\n         vec4 colorCurrent1 = texture2D(textureIn, gl_TexCoord[0].st + offset * r);\n         vec4 colorCurrent2 = texture2D(textureIn, gl_TexCoord[0].st - offset * r);\n\n         colorCurrent1.rgb *= colorCurrent1.a;\n         colorCurrent2.rgb *= colorCurrent2.a;\n\n         innerAlpha += (colorCurrent1 + colorCurrent2) * weights[int(r)];\n\n     }\n\n     gl_FragColor = vec4(color.rgb, mix(innerAlpha.a, 1.0 - exp(-innerAlpha.a * exposure), step(0.0, direction.y)));\n }\n".getBytes()), 35632);
                case "cornerTex" -> this.createShader(new ByteArrayInputStream(this.roundedCornerRectTexture.getBytes()), 35632);
                case "round" -> this.createShader(new ByteArrayInputStream(this.roundedRect.getBytes()), 35632);
                case "fog" -> this.createShader(new ByteArrayInputStream("#version 120\n\nuniform float BLUR_AMOUNT = 1.6;\nuniform sampler2D depthtex0;\nuniform float near;\nuniform float far;\nuniform sampler2D textureIn;\nuniform vec2 texelSize, direction;\nuniform float startRadius;\nuniform float endRadius;\nuniform float depthStart;\nuniform float weights[256];\n\n\n#define offset texelSize * direction\n#define clipping far\n#define NOISE .5/255.0\n\n\nfloat getDepth(vec2 coord) {\n    return 2.0 * near * far / (far + near - (2.0 * texture2D(depthtex0, coord).x - 1.0) * (far - near)) / clipping;\n}\n\nvoid main() {\n    float depth = getDepth(gl_TexCoord[0].st);\n    vec4 finalColor;\n    if (depth >= depthStart) {\n        float totalWeight = weights[0];\n        vec3 blr = texture2D(textureIn, gl_TexCoord[0].st).rgb * weights[0];\n\n        for (float f = 0f; f <= mix(startRadius, endRadius, depth - depthStart); f++) {\n            blr += texture2D(textureIn, gl_TexCoord[0].st + f * offset).rgb * (weights[int(abs(f))]);\n            blr += texture2D(textureIn, gl_TexCoord[0].st - f * offset).rgb * (weights[int(abs(f))]);\n            totalWeight += (weights[int(abs(f))]) * 2.0;\n        }\n\n        finalColor = vec4(blr / totalWeight, 1);\n\n    }\n    else {\n        finalColor = vec4(texture2D(textureIn, gl_TexCoord[0].st).rgb, 1.0);\n    }\n\n    gl_FragColor = finalColor;\n}\n".getBytes()), 35632);
                case "glow" -> this.createShader(new ByteArrayInputStream(this.glowRect.getBytes()), 35632);
                case "out" -> this.createShader(new ByteArrayInputStream("#version 120\n\n// \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0445\nuniform vec2 size; // \u0440\u0430\u0437\u043c\u0435\u0440 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\nuniform vec4 round; // \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b \u0441\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u044f \u0443\u0433\u043b\u043e\u0432\nuniform vec2 smoothness; // \u043f\u043b\u0430\u0432\u043d\u043e\u0441\u0442\u044c \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043e\u0442 \u0446\u0432\u0435\u0442\u0430 \u043a \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u0438\nuniform float value; // \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\nuniform vec4 color; // \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\nuniform float outlineSize; // \u0440\u0430\u0437\u043c\u0435\u0440 \u043e\u0431\u0432\u043e\u0434\u043a\u0438\nuniform vec4 outlineColor; // \u0446\u0432\u0435\u0442 \u043e\u0431\u0432\u043e\u0434\u043a\u0438\n\n// \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0440\u0430\u0441\u0447\u0435\u0442\u0430 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\nfloat test(vec2 vec_1, vec2 vec_2, vec4 vec_4) {\n    vec_4.xy = (vec_1.x > 0.0) ? vec_4.xy : vec_4.zw;\n    vec_4.x = (vec_1.y > 0.0) ? vec_4.x : vec_4.y;\n    vec2 coords = abs(vec_1) - vec_2 + vec_4.x;\n    return min(max(coords.x, coords.y), 0.0) + length(max(coords, vec2(0.0f))) - vec_4.x;\n}\n\nvoid main() {\n    vec2 st = gl_TexCoord[0].st * size; // \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u0438\u043a\u0441\u0435\u043b\u044f\n    vec2 halfSize = 0.5 * size; // \u043f\u043e\u043b\u043e\u0432\u0438\u043d\u0430 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430\n    float sa = 1.0 - smoothstep(smoothness.x, smoothness.y, test(halfSize - st, halfSize - value, round));\n    // \u0440\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0433\u0440\u0430\u043d\u0438\u0446\u044b\n    gl_FragColor = mix(vec4(color.rgb, 0.0), vec4(color.rgb, color.a), sa); // \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u0441 \u043f\u0440\u043e\u0437\u0440\u0430\u0447\u043d\u043e\u0441\u0442\u044c\u044e sa\n   \n    // \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u0432\u043e\u0434\u043a\u0443\n    vec2 outlineSizeVec = size + vec2(outlineSize);\n    float outlineDist = test(halfSize - st, halfSize - value, round);\n    float outline = smoothstep(smoothness.x, smoothness.y, outlineDist) - smoothstep(smoothness.x, smoothness.y, outlineDist - outlineSize);\n    if (outlineDist < outlineSize)\n        gl_FragColor = mix(gl_FragColor, outlineColor, outline);\n}\n".getBytes()), 35632);
                case "up" -> this.createShader(new ByteArrayInputStream(this.kawaseUpBloom.getBytes()), 35632);
                case "down" -> this.createShader(new ByteArrayInputStream(this.kawaseDownBloom.getBytes()), 35632);
                case "bloom" -> this.createShader(new ByteArrayInputStream("#version 120\n\nuniform sampler2D textureIn, textureToCheck;\nuniform vec2 texelSize, direction;\nuniform float exposure, radius;\nuniform float weights[64];\nuniform bool avoidTexture;\n\n#define offset direction * texelSize\n\nvoid main() {\n    if (direction.y == 1 && avoidTexture) {\n        if (texture2D(textureToCheck, gl_TexCoord[0].st).a != 0.0) discard;\n    }\n    vec4 innerAlpha = texture2D(textureIn, gl_TexCoord[0].st);\n    innerAlpha *= innerAlpha.a;\n    innerAlpha *= weights[0];\n\n\n\n    for (float r = 1.0; r <= radius; r ++) {\n        vec4 colorCurrent1 = texture2D(textureIn, gl_TexCoord[0].st + offset * r);\n        vec4 colorCurrent2 = texture2D(textureIn, gl_TexCoord[0].st - offset * r);\n\n        colorCurrent1.rgb *= colorCurrent1.a;\n        colorCurrent2.rgb *= colorCurrent2.a;\n\n        innerAlpha += (colorCurrent1 + colorCurrent2) * weights[int(r)];\n\n    }\n\n    gl_FragColor = vec4(innerAlpha.rgb / innerAlpha.a, mix(innerAlpha.a, 1.0 - exp(-innerAlpha.a * exposure), step(0.0, direction.y)));\n}".getBytes()), 35632);
                case "shadow" -> this.createShader(new ByteArrayInputStream("#version 120\n\nuniform sampler2D sampler1;\nuniform sampler2D sampler2;\nuniform vec2 texelSize;\nuniform vec2 direction;\nuniform float radius;\nuniform float kernel[256];\n\nvoid main(void)\n{\n    vec2 uv = gl_TexCoord[0].st;\n    vec4 pixel_color = texture2D(sampler1, uv);\n    pixel_color.rgb *= pixel_color.a;\n    pixel_color *= kernel[0];\n\n    for (float f = 1; f <= radius; f++) {\n        vec2 offset = f * texelSize * direction;\n        vec4 left = texture2D(sampler1, uv - offset);\n        vec4 right = texture2D(sampler1, uv + offset);\n        left.rgb *= left.a;\n        right.rgb *= right.a;\n        pixel_color += (left + right) * kernel[int(f)];\n    }\n\n    gl_FragColor = vec4(pixel_color.rgb / pixel_color.a, pixel_color.a);\n}\n".getBytes()), 35632);
                case "texture" -> this.createShader(new ByteArrayInputStream(this.texture.getBytes()), 35632);
                case "outline" -> this.createShader(new ByteArrayInputStream(this.outline.getBytes()), 35632);
                case "outlineC" -> this.createShader(new ByteArrayInputStream(this.colorOut.getBytes()), 35632);
                case "gradientMask" -> this.createShader(new ByteArrayInputStream(this.gradientMask.getBytes()), 35632);
                case "blur" -> this.createShader(new ByteArrayInputStream("#version 120\n\nuniform sampler2D textureIn;\nuniform sampler2D textureOut;\nuniform vec2 texelSize, direction;\nuniform float radius, weights[256];\n\n#define offset texelSize * direction\n\nvoid main() {\n    vec2 uv = gl_TexCoord[0].st;\n    uv.y = 1.0f - uv.y;\n\n    float alpha = texture2D(textureOut, uv).a;\n    if (direction.x == 0.0 && alpha == 0.0) {\n        discard;\n    }\n\n    vec3 color = texture2D(textureIn, gl_TexCoord[0].st).rgb * weights[0];\n    float totalWeight = weights[0];\n\n    for (float f = 1.0; f <= radius; f++) {\n        color += texture2D(textureIn, gl_TexCoord[0].st + f * offset).rgb * (weights[int(abs(f))]);\n        color += texture2D(textureIn, gl_TexCoord[0].st - f * offset).rgb * (weights[int(abs(f))]);\n\n        totalWeight += (weights[int(abs(f))]) * 2.0;\n    }\n\n    gl_FragColor = vec4(color / totalWeight, 1.0);\n}\n".getBytes()), 35632);
                case "alphaMask" -> this.createShader(new ByteArrayInputStream(this.alphaMask.getBytes()), 35632);
                case "roundRectOutline" -> this.createShader(new ByteArrayInputStream("#version 120\n            \nuniform vec2 location, rectSize;\nuniform vec4 color, outlineColor1,outlineColor2,outlineColor3,outlineColor4;\nuniform float radius, outlineThickness;\n#define NOISE .5/255.0\n\nfloat roundedSDF(vec2 centerPos, vec2 size, float radius) {\n    return length(max(abs(centerPos) - size + radius, 0.0)) - radius;\n}\n\nvec3 createGradient(vec2 coords, vec3 color1, vec3 color2, vec3 color3, vec3 color4)\n{\n    vec3 color = mix(mix(color1.rgb, color2.rgb, coords.y), mix(color3.rgb, color4.rgb, coords.y), coords.x);\n    //Dithering the color\n    // from https://shader-tutorial.dev/advanced/color-banding-dithering/\n    color += mix(NOISE, -NOISE, fract(sin(dot(coords.xy, vec2(12.9898, 78.233))) * 43758.5453));\n    return color;\n}\n\nvoid main() {\n    float distance = roundedSDF(gl_FragCoord.xy - location - (rectSize * .5), (rectSize * .5) + (outlineThickness * 0.5) - 1.0, radius);\n\n    float blendAmount = smoothstep(0., 2., abs(distance) - (outlineThickness * 0.5));\n    vec4 outlineColor = vec4(createGradient(gl_TexCoord[0].st, outlineColor1.rgb, outlineColor2.rgb, outlineColor3.rgb, outlineColor4.rgb), outlineColor1.a);\n    vec4 insideColor = (distance < 0.) ? color : vec4(outlineColor.rgb,  0.0);\n    gl_FragColor = mix(outlineColor, insideColor, blendAmount);\n}\n".getBytes()), 35632);
                case "gradientRoundRect" -> this.createShader(new ByteArrayInputStream(this.gradientRoundRect.getBytes()), 35632);
                default -> this.createShader(mc.getResourceManager().getResource(new ResourceLocation("expensive/shader/" + fragmentShaderLoc)).getInputStream(), 35632);
            };
            ARBShaderObjects.glAttachObjectARB(this.programID, fragmentShaderID);
            ARBShaderObjects.glAttachObjectARB(this.programID, this.createShader(new ByteArrayInputStream(this.vertex.getBytes()), 35633));
            ARBShaderObjects.glLinkProgramARB(this.programID);
        } catch (IOException exception) {
            exception.fillInStackTrace();
            System.out.println("\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0435: " + fragmentShaderLoc);
        }
    }

    public static void init() {
        CORNER_ROUND_SHADER = new ShaderUtil("corner");
        CORNER_ROUND_SHADER_TEXTURE = new ShaderUtil("cornerTex");
        GLOW_ROUND_SHADER = new ShaderUtil("glow");
        TEXTURE_ROUND_SHADER = new ShaderUtil("texture");
        ROUND_SHADER = new ShaderUtil("round");
        GRADIENT_ROUND_SHADER = new ShaderUtil("gradientRoundRect");
        ROUND_SHADER_OUTLINE = new ShaderUtil("roundRectOutline");
        GRADIENT_MASK_SHADER = new ShaderUtil("gradientMask");
    }

    public int getUniform(String name) {
        return ARBShaderObjects.glGetUniformLocationARB(this.programID, name);
    }

    public static float calculateGaussianValue(float x, float sigma) {
        double PI2 = 3.141592653;
        double output = 1.0 / Math.sqrt(2.0 * PI2 * (double)(sigma * sigma));
        return (float)(output * Math.exp((double)(-(x * x)) / (2.0 * (double)(sigma * sigma))));
    }

    public void setUniformfb(String name, FloatBuffer buffer) {
        ARBShaderObjects.glUniform1fvARB(GL30.glGetUniformLocation(this.programID, name), buffer);
    }

    public void attach() {
        ARBShaderObjects.glUseProgramObjectARB(this.programID);
    }

    public void detach() {
        GL20.glUseProgram(0);
    }

    public void setUniform(String name, float ... args2) {
        int loc = ARBShaderObjects.glGetUniformLocationARB(this.programID, name);
        switch (args2.length) {
            case 1: {
                ARBShaderObjects.glUniform1fARB(loc, args2[0]);
                break;
            }
            case 2: {
                ARBShaderObjects.glUniform2fARB(loc, args2[0], args2[1]);
                break;
            }
            case 3: {
                ARBShaderObjects.glUniform3fARB(loc, args2[0], args2[1], args2[2]);
                break;
            }
            case 4: {
                ARBShaderObjects.glUniform4fARB(loc, args2[0], args2[1], args2[2], args2[3]);
                break;
            }
            default: {
                throw new IllegalArgumentException("\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0434\u043b\u044f uniform '" + name + "'");
            }
        }
    }

    public void setUniform(String name, int ... args2) {
        int loc = ARBShaderObjects.glGetUniformLocationARB(this.programID, name);
        switch (args2.length) {
            case 1: {
                ARBShaderObjects.glUniform1iARB(loc, args2[0]);
                break;
            }
            case 2: {
                ARBShaderObjects.glUniform2iARB(loc, args2[0], args2[1]);
                break;
            }
            case 3: {
                ARBShaderObjects.glUniform3iARB(loc, args2[0], args2[1], args2[2]);
                break;
            }
            case 4: {
                ARBShaderObjects.glUniform4iARB(loc, args2[0], args2[1], args2[2], args2[3]);
                break;
            }
            default: {
                throw new IllegalArgumentException("\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0434\u043b\u044f uniform '" + name + "'");
            }
        }
    }

    public void setUniformf(String var1, float ... var2) {
        int var3 = ARBShaderObjects.glGetUniformLocationARB(this.programID, var1);
        switch (var2.length) {
            case 1: {
                ARBShaderObjects.glUniform1fARB(var3, var2[0]);
                break;
            }
            case 2: {
                ARBShaderObjects.glUniform2fARB(var3, var2[0], var2[1]);
                break;
            }
            case 3: {
                ARBShaderObjects.glUniform3fARB(var3, var2[0], var2[1], var2[2]);
                break;
            }
            case 4: {
                ARBShaderObjects.glUniform4fARB(var3, var2[0], var2[1], var2[2], var2[3]);
            }
        }
    }

    public static Framebuffer createFrameBuffer(Framebuffer framebuffer) {
        if (framebuffer == null || framebuffer.framebufferWidth != mc.getMainWindow().getWidth() || framebuffer.framebufferHeight != mc.getMainWindow().getHeight()) {
            if (framebuffer != null) {
                framebuffer.deleteFramebuffer();
            }
            return new Framebuffer(Math.max(mc.getMainWindow().getWidth(), 1), Math.max(mc.getMainWindow().getHeight(), 1), true, false);
        }
        return framebuffer;
    }

    public static void update(Framebuffer framebuffer) {
        if (framebuffer.framebufferWidth != mc.getMainWindow().getWidth() || framebuffer.framebufferHeight != mc.getMainWindow().getHeight()) {
            framebuffer.createBuffers(mc.getMainWindow().getWidth(), mc.getMainWindow().getHeight(), false);
        }
    }

    public static void drawQuads(float x, float y, float width, float height) {
        GL20.glBegin(7);
        GL20.glTexCoord2f(0.0f, 0.0f);
        GL20.glVertex2f(x, y);
        GL20.glTexCoord2f(0.0f, 1.0f);
        GL20.glVertex2f(x, y + height);
        GL20.glTexCoord2f(1.0f, 1.0f);
        GL20.glVertex2f(x + width, y + height);
        GL20.glTexCoord2f(1.0f, 0.0f);
        GL20.glVertex2f(x + width, y);
        GL20.glEnd();
    }

    public static void drawQuads() {
        float width = mc.getMainWindow().getScaledWidth();
        float height = mc.getMainWindow().getScaledHeight();
        GL20.glBegin(7);
        GL20.glTexCoord2f(0.0f, 1.0f);
        GL20.glVertex2f(0.0f, 0.0f);
        GL20.glTexCoord2f(0.0f, 0.0f);
        GL20.glVertex2f(0.0f, height);
        GL20.glTexCoord2f(1.0f, 0.0f);
        GL20.glVertex2f(width, height);
        GL20.glTexCoord2f(1.0f, 1.0f);
        GL20.glVertex2f(width, 0.0f);
        GL20.glEnd();
    }

    private int createShader(InputStream inputStream, int shaderType) {
        int shader = ARBShaderObjects.glCreateShaderObjectARB(shaderType);
        ARBShaderObjects.glShaderSourceARB(shader, (CharSequence)FileUtil.readInputStream(inputStream));
        ARBShaderObjects.glCompileShaderARB(shader);
        if (GL20.glGetShaderi(shader, 35713) == 0) {
            System.out.println(GL20.glGetShaderInfoLog(shader, 4096));
            throw new IllegalStateException(String.format("Shader (%s) failed to compile!", shaderType));
        }
        return shader;
    }

    static {
        kernelCache = new HashMap();
    }
}

